# 스위프트 언어의 특징

- 정적 바인딩 : 변,상수를 타입추론을 해서 동작바인딩으로 많이 오해함.
             동적 바인딩(파이썬, 자바스크립트)
- 높은 생산성
- 데이터 타입 구분이 엄격
             컴파일 단계에서 미리 정의 되어야 함

 

# 스위프트에서 차용하고 있는 주요 기능들

- 딕셔너리(해시 테이블)
- 데이터 타입 추론 : 함수형 프로그래밍 언어에서 주로 사용됨
             코드를 실행하기 전 미리 버그를 잡을 수 있는 장점
- 데이터 구조체 타입 선언 : 데이터 구조체에 저장될 타입을 컴파일러에게 미리 알려 줄 수 있음
             var name = Dictionary<Int, String>()
- 문자열 템플릿: \( ), 문자열 연결에 주로 이용됨
- 선택사항인 세미콜론: 한 줄에 여러 변수 선언등을 할 때 이용됨
- 프로토콜: 클래스가 정의에 부합하는 함수를 제공할 수 있도록, 함수구조를 정의함
- 튜플: 두개 이상의 값을 반환할 때 사용
- 자동참조카운트(ARC)
- 부호가 있는 정수와 없는 정수
- 클로저: 소량의 코드를 묶어서 함수처럼 전달
- 멀티라인 쿼우팅: swift      4.0부터 """ """을 이용해 여러줄의 문자열 입력 가능 => \n 사용안해도 됨

 

# 구조적 특징

- 빠름: GCC 대신 LLVM 컴파일러를 사용함
             LLVM: 언어와 구조로부터 독립적이며, 언어 모듈과 시스템을 위한 코드 생성 부의 사이에 위치
             코드 최적화기로 스위프트의 성능 극대화

- 설계에 의한 안전성

- - 변수, 상수는 반드시 선언 후 사용
  - 타입 추론 기능
  - 개발자가 정의하지 않은 배열 값에 승인하지 않은 값들이 주입 될 수 없도록
                 Array bounds check 기능 추가
  - 포인터로 직접 접근하지 않고, 클래스를 통해서만 간접적으로 레퍼런스에 접근함
  - ARC로 메모리 누수 현상에 안전성을 높임

- 현대적

- - 가독성이 좋음

  - 유지보수를 쉽게 하기 위해, 헤더파일의 사용 대신 메인파일에 코드 작성가능

  - - 선언부(헤더파일)와 구현부(소스파일)이 하나로 합쳐져 swift 파일로 작성됨
    - swift파일에서 import를 시켜서 바로 모듈을 불러오면 됨

  - 옵셔널 / 제너릭 / 클로저 / 튜플 이용

- 상호 반응

- - 플레이 그라운드 이용

- 완전한 플랫폼

- - 스위프트 언어 하나로 앱의 모든 기능을 구현 가능

- 통합

- - Objective-c와 함께 이용가능(Bridging,       Mix and Match)

 

 

# Objectiv-C VS Swift

|                                                              | Objectiv-c                                                   | Swift                                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 파일통합                                                     | 헤더파일      소스파일 구분                                  | swift로 통합                                                 |
| 클래스의 정의구현                                            | 헤더파일에 클래스의 인터페이스 정의,      소스파일에서 정의된 인터페이스 구현 | 인터페이스정의 없이 바로 클래스 구현                         |
| 클래스 상속                                                  | 반드시 상위 클래스 상속      상위 클래스가 없으면, 최상위 클래스인 NSObject 상속 | 상속 받지 않아도 됨                                          |
| 상속                                                         | 다중상속X      프로토콜- 카테고리 개념으로 이용, 클래스만 이용가능 | 다중상속X      프로토콜- Extension 이용                      |
| 범용타입                                                     | id타입                                                       | Any: 구조체, 클래스, 열거형, 함수      AnyObject: 클래스     |
| 메소드 호출                                                  | 메시지 전송 방식      스몰토크방식 [ ] 이용      [인스턴스명   incrementBy:3] | 일반적인 객체지향 메소드 호출      객체와 메소드 사이는 점(.) 이용      인스턴스명.incrementBy(3) |
| nil의 의미                                                   | 존재하지 않는 객체 참조                                      | 옵셔널 타입의 기본값으로 사용      '값이 존재하지 않음'      |
| 포인터 사용                                                  | 레퍼런스 참조                                                | 클래스: 레퍼런스참조(참조타입)      구조체: 객체 복사(값타입) |
| 객체지향타입                                                 | 클래스 제공      @Interface 어노테이션 이용해서 선언      @Implementation 어노테이션 이용해서 구현 | 모두 인스턴스 생성가능                                       |
| 익명함수      한번만 사용되는 코드를 함수로 구현하는 것을 방지 | Block 개념                                                   | Closer                                                       |
| 오류처리                                                     | 오류를 검사할뿐 오류 처리를 해주진 않음                      | try ~ catch문 이용                                           |