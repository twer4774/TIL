# 2-7. Construct and destruct of Object(객체의 생성과 소멸) - Finalizer

## Finalizer의 사용을 피하자

- 파이널라이저(Finalizer) : 꼭 필요할 때 우리 클래스에 정의하는 finalize() 메서드
  - 우리 클래스의 객체가 더 이상 사용되지 않으면 JVM의 가비지 컬렉터가 메모리에서 우리 객체를 없애기 전에 finalize() 메서드를 호출해 준다면 가비지 컬렉터는 new 키워드로 생성된 객체의 메모리만을 클린업해 줄 수 있으므로 객체가 사용하던 그 외의 메모리나 자원을 클린업 할 필요가 없을 때만 고려하는 것이 좋음
- 파이널라이저는 예측불가에 위험하기도 하며 일반적으로는 불필요함 
  - 파이널라이저를 사용하면 예측이 어려운 프로그램 실행과 성능 저하 및 이식성의 문제가 생길 수 있음
- 파이널라이저의 객체들은 쓰레드에서 다른 쓰레드 객체보다 우선순위가 낮음 => 명시적으로 파이널라이저 해줘야 해결 가능
- 주의사항
  - 영속적인 상태를 변경하기 위해 파이널라이저를 절대 사용하면 안됨
    - 데이터베이스 공유 자원에 걸려잇는 영속적 락(lock)을 해지하는데 파이널라이저를 사용하면 시스템 전체를 멈추게 됨
  - 가급적 종료 메서드는 try~finally와 함께 사용하여 확실히 실행되도록 할 것

```java
//try-finally 블록을 사용하면 종료 메서드의 실행 보장
Foo foo = new Foo(...);
try{
  //foo 객체를 사용해서 해야 할 일들을 처리
	...
} finally{
  foo.terminate(); //종료 메서드 호출
}
```

## 파이널 라이저를 사용하는 경우

### 1. 생성된 객체를 갖고 있는 코드에서 그 객체의 종료 메서드 호출을 빠뜨렸을 경우(안정망역할)

- 되도록 일어나서는 안되지만 안전망 역할로 자원의 해지가 이루어지지 않은 객체를 늦게나마 해지 시킬 때 사용
  - 자원의 사용이 완전히 끝나지 않을 경우 경고메시지로 기록해야 함

- FileInputStream, FileOutputStream, Timer, Connection은 파이널라이저를 가지고 있음

### 2. 네이티브 피어(native peer)객체와 관련

- 네이티브 피어 : 네이티브 메서드를 통해 일반 자바 객체가 자신의 일을 위임하는 네이티브 객체
  - 네이티브 피어는 일반 자바 객체가 아니므로, 그것과 연관된 자바 피어 객체가 소멸된면 가비지 컬렉터가 알지 못하며 재활용 할 수도 없음 => 파이널 라이저가 도움이 됨

## 파이널 라이저 가디언

- 자신을 포함한 외부 클래스의 각 인스턴스 당 하나씩 생성됨
- 외부 클래스 인스턴스는 자신의 파이널라이저 가디언 객체 참조를 private 인스턴스 필드에 보존
  - 파이널라이저 가디언은 외부 클래스 인스턴스와 동시에 파이널라이즈를 하게 됨

```java
//파이널라이저 가디언
public class Foo{
  //이 객체의 목적은 외부 클래스(Foo) 객체의 파이널라이즈를 수행하는 것
  private final Object finalizerGuardian = new Object(){
    @Override protected void finalize() throws Throwable{
      ...//외부 클래스(Foo) 객체의 파이널라이즈를 수행하는 코드
    }
  };
  ... // 나머지 코드 생략
}
```

