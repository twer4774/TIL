# Modifier(제어자)

### 접근제어자

- public
- protected
- default
- private

### 그 외

- static, final, abastract, native, tarnsient, synchronized, vloatile, strictfp



### static - 클래스의, 공통적인

- 클래스변수(static멤버변수)는 인스턴스에 관계없이 같은 값을 가짐
  - 하나의 변수를 모든 인스턴스가 공유
- static이 붙은 멤버변수와 메서드, 초기화 블럭은 인스턴스의 생성이 없이도 사용 가능
- 인스턴스 멤버를 사용하지 않는 메서드는 static을 붙여서 static메서드로 선언하는것을 고려하는 것이 좋음
  - 가능하다면 static메서드로 하는것이 인스턴스를 생성하지 않고도 호출이 가능해서 더 편리하고 속도도 빠름
  - static초기화 블럭은 클래스가 메모리에 로드될 때 단 한번만 수해오디며, 주로 클래스변수(static변수)를 초기화하는데 주로 사용

### final - 마지막의, 변경될 수 없는

- 클래스, 메서드, 멤버변수, 지역변수에서 사용가능
- 변경할 수 없는 상수를 표시할 때 사용
  - 오버라이딩 불가
  - 클래스에서 사용되면 자손클래스를 사용할 수 없다(상속 불가)
- 생성자를 이용한 final멤버 변수의 초기화
  - final이 붙은 변수는 상수이므로 선언과 초기화를 동시에 하지만, 인스턴스 변수의 경우 생성자에서 초기화 되도록 할 수 있음
    - 클래스 내에 매개변수를 갖는 생성자를 선언하여, 인스턴스를 생성할 때 final이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자의 매개변수로부터 제공 받는 방법 - 단, 생성자를 이용해 한번만 초기화 하는 것(final이므로 바뀌면 안됨)

### abstract - 추상의, 미완성의

- 클래스, 메서드에서 사용 가능
- 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용
  - 인스턴스를 생성할 수 없음

```java
abstract class AbstractTest{ //추상클래스
  abstract void move(); //추상메서드(구현부가 없음)
}
```

## 접근제어자(access modifer)

- 멤버 또는 클래스에 사용되어 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할
- 접근 제어자가 붙어있지 않으면 default로 생성
  - private - 같은 클래스 내에서만 접근가능
  - default - 같은 패키지 내에서만 접근가능
  - protected - 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능
  - public - 접근 제한이 전혀 없음
  - 넓은 범위 순 -> public > protected > default > private

### 접근 제어자를 이용한 캡슐화

- 접근 제어자를 사용하는 이유
  - 클래스의 내부에 선언된 데이터를 보호하기 위함
  - 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위함

### 생성자의 접근 제어자

- 보통 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만 다르게 지정할 수도 있음
  - private생성자를 지정하면 외부에서는 생성자를 접근할 수 없어 인스턴의 생성이 불가함
    - 인스턴스를 생성해서 반환해주는 public 메서드를 제공하여 외부에서 인스턴스를 사용하도록 지원해줘야 함(public static 이용)
  - 내부에서는 인스턴스를 생성하여 사용

```java
class Singleton{
	private static Singleton s = new Singleton(); //getInstance()에서 사용될 수 있도록 인스턴스가 미리 생성되어야 하므로 static이어야 함
  
  private Singleton(){ 
    
  }
  
  //private 생성자이므로 인스턴스를 생성하지 않고 사용할 수 있도록 public static으로 지정
  public static Singleton getInstance(){
    return s;
  }
}
```

- 위와 같은 방법으로 사용할 수 있는 인스턴스의 개수를 제한할 수 있음
- 생성자가 private이라면 다른 클래스의 조상이 될 수 없음
  - 자손 클래스의 인스턴스를 생성할 때 조상 클래스의 생성자를 호출 해야만 하는데, 생성자의 접근 제어자가 private이므로 자손클래스에서 호출하는 것이 불가능하기 때문
  - 따라서 클래스를 정의할 때 private생성자를 가진 클래스는 final제어자를 지정해주어 명시적으로 알리는 것이 좋음

