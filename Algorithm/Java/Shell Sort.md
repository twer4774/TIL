# Shell Sort

- 단순 삽입 정렬의 장점은 살리고 단점을 보완하여 좀 더 빠르게 정렬하는 알고리즘
- 퀵정렬이 등장하기 전에 가장 빠른 정렬 알고리즘으로 쓰임
- 단순 삽입 정렬의 특징
  1. 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬속도가 매우 빨라짐(장점)
  2. 삽입할 위치가 많이 떨어져 있다면 이동(대입) 횟수가 많아짐(단점)
- 쉘 정렬 방법
  - 증분 값을 기준으로 배열을 그룹으로 나눔
    - 증분값(h): 4, 2, 1처럼 그룹화 하는 값
    - h = 121, 40, 13, 4, 1 과 같이 증분 값을 정함. 보통은 1을 기준으로 했을 때, '3의배수 +1의  수열'을 이용
    - ~~단, 초기값이 너무 크면 효과가 없으므로 배열의 길이를 9로 나누었을 때의 값을 넘지 않아야 함~~
      - ~~배열의 길이가 8이라면 8/9의 값은 0.8888…. h의 초기값은 0.8888… 을 넘을 수 없다???~~
    - 전체 배열의 길이(N)/3 + 1을 증분값으로 하면 빠름
      - 보통은 N/2로 하여 증분을 시도하지만, N/3+1을 했을 때 더 빠르다고 알려져 있음
      - 배열의 길이가 8이라면, 8/3 + 1 = 3.66666… => 4를 증분값으로 한다.
  - 각 그룹별로 단순 삽입정렬 수행
  - 그룹을 합치면서 단순 삽입 정렬 수행

## 쉘 정렬 방법

- [8, 1, 4, 2, 7, 6, 3, 5] 의 값 정렬

1. 배열의 길이가 8이므로 8/3 + 1 = 4를  증분값으로 한다.

   이때, 4개의 위치만큼 떨어진 값들을 그룹화 시킨다.
   {8, 7}, {1, 6}, {4, 3}, {2, 5}

2. 각 그룹별로 단순 삽입 정렬 수행
   {7,8}, {1,6}, {3,4}, {2,5}
   7, 8, 1, 6, 3, 4, 2, 5

3. 두개의 그룹으로 그룹화 => 2-정렬
   이때, 2개의 위치만큼 떨어진 값들을 그룹화 시킨다.
   {7, 1, 3, 2}, {8, 6, 4, 5}

4. 각 그룹별로 단순 삽입 정렬 수행
   {1, 2, 3, 7}, {4, 5, 6, 8}

5. 마지막으로 그룹을 단순 삽입 정렬 함
   {1, 2, 3, 4, 5, 6, 7, 8}

- 여러 개의 그룹으로 나누어 단순 삽입정렬에서 발생하는 단점을 커버할 수 있다.
- 정렬의 횟수는 늘지만 삽입(대입)의 횟수가 줄어든다는 점에서 효율적임

```java
package chap06;
import java.util.Scanner;

//쉘 정렬 , 증분값은 40, 13, 4, 1
public class ShellSort {
    //쉘 정렬
    static int shellSort(int[] arr, int n) {

        int count = 0;
        int h;
        for( h = 1; h < n/9; h = h * 3 + 1){;}

        for(; h > 0; h /= 3){
            for(int i = h; i < n; i++){
                int j;
                int tmp = arr[i];
                for(j = i - h; j >= 0 && arr[j] > tmp; j -= h){
                    arr[j + h] = arr[j];
                    count++;
                }
                arr[j + h] = tmp;
                count++;
            }
        }
        return count;

    }
    public static void main(String[] args) {
//        Scanner stdIn = new Scanner(System.in);
//        System.out.println("쉘정렬 길이: ");
//        int nx = stdIn.nextInt();
//        int[] x = new int[nx];
//
//        for(int i = 0; i < nx; i++){
//            System.out.println("x[" + i +"]: ");
//            x[i] = stdIn.nextInt();
//        }
        //임시값들로 대체
        int nx = 8;
        int[] x = {22, 37, 5, 11, 32, 120, 68, 70};
        int count = shellSort(x, nx);

        System.out.println("오름차순으로 정렬");
        for (int i = 0; i < nx; i++) {
            System.out.println("x[" + i + "]=" + x[i]);
        }
        System.out.println("요소는 " + count + "회 옮겨졌습니다.");
    }//main
}
```

