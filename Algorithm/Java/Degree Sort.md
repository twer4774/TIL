# Degree Sort (도수정렬)

- 요소의 대소 관계를 판단하지 않고 빠르게 정렬 할 수 있는 알고리즘

- 최소값과 최대값을 알고 있어야 함

- 정렬 순서

  1. 도수분포표 만들기

     | 5    | 7    | 0    | 2    | 4    | 10   | 3    | 1    | 3    |      |      |
     | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
     |      |      |      |      |      |      |      |      |      |      |      |
     | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
     | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 0    | 0    | 0    |
     | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 1    | 0    | 0    | 0    |
     | 1    | 0    | 0    | 0    | 0    | 1    | 0    | 1    | 0    | 0    | 0    |
     | ...  |      |      |      |      |      |      |      |      |      |      |
     | 1    | 1    | 1    | 2    | 1    | 1    | 0    | 1    | 0    | 0    | 1    |

     - 배열 f의 모든 요소를 0으로 초기화 한다. 크기는 정렬하는 배열의 가장 큰 요소가 10이므로 인덱스 10이 되도록 총 11개의 크기를 갖는다
     - 5부터 해당하는 배열의 위치에 개수를 파악한다

  2. 누적도수분포표 만들기

     - 누적된 값을 나타내는 누적도수분포표 만들기

       | 1    | 1    | 1    | 2    | 1    | 1    | 0    | 1    | 0    | 0    | 1    |
       | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
       | 1    | 2    | 1    | 2    | 1    | 1    | 0    | 1    | 0    | 0    | 1    |
       | 1    | 2    | 3    | 2    | 1    | 1    | 0    | 1    | 0    | 0    | 1    |
       | 1    | 2    | 3    | 5    | 1    | 1    | 0    | 1    | 0    | 0    | 1    |
       | ...  |      |      |      |      |      |      |      |      |      |      |
       | 1    | 2    | 3    | 5    | 6    | 7    | 7    | 8    | 8    | 8    | 9    |

       - 2번째 요소부터 누적개수를 구함

  3. 목적 배열 만들기

     - 값이 몇번째에 있는지 알 수 있으므로, 거의 정렬을 마쳤다고 볼 수 있다

     - 남은 작업은 배열의 각 요솟값과 누적도수분포표 f를 대조하여 정렬을 마친 배열을 만드는 작업

     - 배열 a와 같은 요소의 개수를 갖는 작업용 배열 b가 필요

       | 5    | 7    | 0    | 2    | 4    | 10   | 3    | 1    | 3    |      |      |
       | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
       |      |      |      |      |      |      |      |      |      |      |      |
       | 1    | 2->1 | 3    | 5->4 | 6    | 7    | 7    | 8    | 8    | 8    | 9    |
       |      |      |      |      |      |      |      |      |      |      |      |
       |      |      |      |      | 3    |      |      |      |      |      |      |
       |      | 1    |      |      | 3    |      |      |      |      |      |      |
       | ...  |      |      |      |      |      |      |      |      |      |      |
       |      |      |      |      |      |      |      |      |      |      |      |

       - 마지막 요소 3의 누적도수 위치 f[3]에 5가 저장되어 있음
       - 따라서 마지막 배열의 b[4]값(5의 인덱스)에 3을 저장함
       - f[3]의 값을 5에서 1만큼 감소시켜 4로 만듦
       - 뒤에서 두번째 값 1의 누적도수 위치 f[1]에 2가 저장되어 있음
       - 따라서 마지막 배열의 b[1]값(2의 인덱스)에 1을 저장
       - f[1]의 값을 2에서 1만큼 감소시켜 1로 만듦

  4. 배열 복사하기

     - 정렬은 끝났지만 정렬 결과를 저장한 곳은 작업 배열 b
     - 따라서 배열 b를 a에 복사해야 함
     - for문으로 정렬 가능

     ```java
     import java.util.Scanner;
     
     //도수정렬
     
     public class Fsort {
         //도수 정렬(0 이상 max 이하의 값을 입력)
         static void fSort(int[] arr, int n, int max) {
             int[] f = new int[max + 1]; //누적 도수
             int[] b = new int[n]; //작업용 목적 배열
             
             for(int i = 0; i < n; i++) f[arr[i]]++; //1단계 - 도수분포표만들기
             for(int i = 1; i <= max; i++) f[i] += f[i - 1]; //2단계 - 누적도수분포표만들기
             for(int i = n - 1; i >= 0; i--) b[--f[arr[i]]] = arr[i];//3단계 - 목적배열만들기
             for(int i = 0; i < n; i++) arr[i] = b[i]; //4단계 - 배열복사하기
         }
         
         public static void main(String[] args) {
             Scanner stdin = new Scanner(System.in);
     
             System.out.println("도수 정렬 요소수 : ");
             int nx = stdin.nextInt();
             int[] x = new int[nx];
     
             for (int i = 0; i < nx; i++) {
                 do {
                     System.out.println("x[" + i + "] : ");
                     x[i] = stdin.nextInt();
                 } while (x[i] < 0);
             }
     
             
             //배열 x의 최댓값을 구하여 max에 대입
             int max = x[0];
             for (int i = 1; i < nx; i++) {
                 if(x[i] > max) max = x[i];
             }
     
             fSort(x, nx, max);
     
             System.out.println("오름차순으로 정렬");
             for (int i = 0; i < nx; i++) {
                 System.out.println("x[" + i + "]= " + x[i]);
             }
         }//main
     }
     ```

     - 배열의 모든 요소값이 0 이상 max이하임을 전제로 도수 정렬 실행
     - 데이터의 비교, 교환 작업이 필요없어 매우 빠름
     - 단일 for문을 사용하여 효율성이 높음
     - 단, 도수분포표가 필요하므로 데이터의 최소값과 최대값을 알아야 사용 가능