# 충돌해결방법: 개방주소법

## 개방주소법(조사법)

- 해시 테이블에 계산한 주소가 비어있지 않으면, 다음 주소가 비었는지 조사
- 만약 주소가 비었다면 바로 저장하고, 비어있지 않다면 다음주소로 이동해 다시 빈 주소인지 확인을 반복 수행
- 다음 주소를 어떻게 정하는에 따라 선형 조사법, 제곱 조사법, 이중해싱 방법으로 나뉨

### 선형조사(Linear probing)

- 일정 상수만큼 증가시켜 다시 조사하는 방법

```
h(k) = (k + try_count) mod M
k -> (충돌) -> (k+1) -> (충돌) -> (k+2) - > (충돌) -> (k+3)...
```

- 장점: 비교적 간단한 계산으로 빈 주소를 찾음
- 단점: 일단 충돌이 발생하면 충돌이 시작된 주소 주위로 군집화 현상이 나타남

```
M: 5, 해시함수: mod 5, 저장되는 검색키: {1, 3, 8, 13}
1. 1 -> 1 mod 5 = 1
2. 3 -> 3 mod 5 = 3
3. 8 -> 8 mod 5 = 3(충돌) => 재계산 => (8+1) mod 5 = 4 => 4에 저장
4. 13 -> 13 mod 5 = 3(충돌) => 재계산 => (13+1) mod 5 = 4 => 충돌 =>(13+2) mod 5 = 0 => 0에 저장
```

### 제곱조사(Quadric probing)

- 충돌 발생시, 주소를 조사 횟수의 제곱 만큼 증가시켜 다시 조사
- 1차충돌 => 1², 2차충돌 => 2², 3차충돌 => 3² … => n차충돌 => n²

```
h(k) = (k + try_count * try_count) mod M
k -> (충돌) -> (k+1) -> (충돌) -> (k+4) -> (충돌) -> (k+9) ... ...
```

- 단점: 선형조사에 비해 군집화 현상이 적지만 여전히 존재함. 해시 테이블의 크기가 반드시 소수여야 함

```
M:5, 해시함수: mod 5, 저장되는 검색키: {1, 3, 8, 13}
1. 1 -> 1 mod 5 = 1
2. 3 -> 3 mod 5 = 3
3. 8 -> 8 mod 5 = 3(충돌) => 재계산 => (8+1) mod 5 = 4 => 4에 저장
4. 13 -> 13 mod 5 = 3(충돌) => 재계산 => (13+1) mod 5 = 4 => 충돌 =>(13+4) mod 5 = 2 => 2에 저장
```

### 이중해시(Double hashing)

- 충돌 발생시, 원래의 해시함수와 추가적인 해시함수를 이용해 주소 증가
- 장점: 군집화를 줄일 수 있음
- 대표적인 방법: 같은 조사간격을 이용하는 방법
  - (조사 간격) = M - (k mod M)

```
M:5, 해시함수: mod 5, 저장되는 검색키: {1, 3, 8, 13}
1. 1 -> 1 mod 5 = 1
2. 3 -> 3 mod 5 = 3
3. 8 -> 8 mod 5 = 3(충돌) => (조사간격) = M-(k mod M) => 5 - (8 mod 5) = 2(조사간격) ==> 이전 충돌 발생주소: 3, 조사간격: 2 => h(k) = (3+2) mod 5 = 0 =>> 0에 값 저장
4. 13 -> 13 mod 5 = 3(충돌) => (조사간격) = M - (k mod M) => 5 - (13 mod 5) = 2(조사간격) ==> 이전 충돌 발생주소: 3, 조사간격: 2 => h(k) = (3+2) mod 5 =0 => (충돌발생) -> 충돌발생주소:0, 조사간격:2 => h(k) = (0+2) mod 5 = 2 ==> 2에 값 저장
```

