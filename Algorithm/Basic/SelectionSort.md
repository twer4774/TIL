# 선택 알고리즘

## 정렬 알고리즘

정렬 알고리즘의 평가기준

- 효율성: 얼마나 빠르게 정렬하는가
- 안정성: 키 값이 같은 자료들은 입력된 순서로 저장되는가 => a1이 a2보다 먼저 저장되었다면, 정렬시 a1 -> a2가 되어야함



## 선택 정렬

- 해당 위치에 맞는 자료를 선택한 후 교환
- 정렬 방법

1. 정렬되지 않은 숫자 중에 가장 작은 숫자 선택
2. 선택한 숫자를 정렬되지 않은 숫자 중 첫번째 숫자와 자리 교환
3. 모든 숫자를 옮길 때 까지 1~2번을 반복 수행함

| Min select |        |        |           |        |           |           |           |           |
| ---------- | ------ | ------ | --------- | ------ | --------- | --------- | --------- | --------- |
| step 0     | 80     | 75     | <u>10</u> | 60     | 15        | 49        | 12        | 25        |
| step 1     | **10** | 75     | 80        | 60     | 15        | 49        | <u>12</u> | 25        |
| step 2     | **10** | **12** | 80        | 60     | <u>15</u> | 49        | 75        | 25        |
| step 3     | **10** | **12** | **15**    | 60     | 80        | 49        | 75        | <u>25</u> |
| step 4     | **10** | **12** | **15**    | **25** | 80        | <u>49</u> | 75        | 60        |
| step 5     | **10** | **12** | **15**    | **25** | **49**    | 80        | 75        | <u>60</u> |
| step 6     | **10** | **12** | **15**    | **25** | **49**    | **60**    | <u>75</u> | 80        |
| step 7     | **10** | **12** | **15**    | **25** | **49**    | **60**    | **75**    | 80        |



| Min   Selection | 0     | 1     | 2     | 3     | 4     | 5    |
| --------------- | ----- | ----- | ----- | ----- | ----- | ---- |
| Step 0          | 5     | 2     | 4     | 6     | 1     | 3    |
| Step 1          | **1** | 2     | 4     | 6     | 5     | 3    |
| Step 2          | **1** | **2** | 4     | 6     | 5     | 3    |
| Step 3          | **1** | **2** | **3** | 6     | 5     | 4    |
| Step 4          | **1** | **2** | **3** | **4** | 5     | 6    |
| Step 5          | **1** | **2** | **3** | **4** | **5** | 6    |

- 특성
  - 자료의 선택과 교환
  - 시간복잡도: 2개의 반복문을 사용해 𝜪(n²)
  - 다른 정렬 알고리즘에 비해 상대적으로 느림
  - 자료의 이동 연산횟수가 𝜪(n)이므로, 크기가 큰 정렬에는 유리 할 수 있음
  - 효율성: 𝜪(n²), 안정성: 보장되지 않음
- 구현

```c
void sectionSort(int value[], int count){
    int i = 0, j = 0;
    int min = 0, temp = 0;
    
    //정렬되지 않은 값 중 최솟값 구하기
    //count - 1인 이유: 마지막 위치 자료는  정렬하지 않아도 됨(이미 최대값이므로)
    for(i = 0; i < count - 1; i++){
        min = i;
        for(j = i+1; j < count; j++){
            min = j;
        }
    }
    //swap
    temp = vlaue[i];
    value[i] = value[min];
    value[min] = temp;
    
    printf("step %d, ", i+1);
}

int main(int argc, char *argv[]){
    int values[] = {80, 75, 10, 60, 15, 49, 12, 25};
    
    seectionSort(vlues, 8)
    
}
```



### Python

```python
#SelectionSort.py
values = [80, 75, 10, 60, 15, 49, 12, 25]
def selection_sort(values, count):
    for i in range(0, count-1):
        min = i
        for j in range(i+1, count):
            if values[j] < values[min]:
                min = j
        temp = values[i]
        values[i] = values[min]
        values[min] = temp

        print("setep {0}" .format(i+1))
        print(values)
	print("정렬 결과 ", values)

selection_sort(values, 8)

#결과
setep 1
[10, 75, 80, 60, 15, 49, 12, 25]
setep 2
[10, 12, 80, 60, 15, 49, 75, 25]
setep 3
[10, 12, 15, 60, 80, 49, 75, 25]
setep 4
[10, 12, 15, 25, 80, 49, 75, 60]
setep 5
[10, 12, 15, 25, 49, 80, 75, 60]
setep 6
[10, 12, 15, 25, 49, 60, 75, 80]
setep 7
[10, 12, 15, 25, 49, 60, 75, 80]
정렬 결과  [10, 12, 15, 25, 49, 60, 75, 80]
```

