# 컴파일러

- 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 프로그램
- 원래의 문서: 소스 코드, 원시 코드
- 출력된 문서: 목적 코드
- 컴파일 : 원시 코드에서 목적 코드로 변환
- 컴파일을 하는 이유: 사람이 이해하는 고수준언어 -> 기계가 이해하는 저수준 언어로 변환

## 컴파일러의 기능

- 고급 언어를 직접 기계어 코드로 변환
- 컴파일러의 조건
  - 변환 과정에서 프로그램의 뜻을 보존해야 한다.
  - 입력 받은 프로그램의 의미를 충실히 따라야 한다.
  - 컴파일러는 입력으로 들어온 프로그램을 어떤 면에서든지 개선해야 한다.
- 장점
  - 한번 컴파일된 바이트 코드는 다른 플랫폼에서 재컴파일 없이 실행 할 수 있다.
- 단점
  - 바이트 코드를 해석해서 실행할 프로그램 구조가 필요하고, 직접 기계어 코드를 실행하는 것 보다 속도가 늦다

## 컴파일러의 구조

- 심볼 테이블을 중심으로 이루어 짐
  - 소스코드
  - 어휘 분석기
    - 소스 코드를 정규 문법에 따라 토큰의 집합으로 변환하는 어휘 분석 또는 스캐닝
    - 어휘 항목을 참조하여 토큰 생성
  - 구문 분석기
    - 소스코드의 문법을 검사하는 구문 분석. 파싱
    - 구문 트리 생성
    - 토큰 간의 관계가 올바르게 생성되었는지를 검사
  - 의미 분석기
    - 구문 트리와 심볼 테이블에 있는 정보를 이용해 소스 코드가 언어 정의에 의미적으로 부합하는지 검사
    - 중요한 기능은 타입검사
    - 정수와 문자열의 덧셈, 값을 0으로 나누는 행동 등과 같이 의미적으로 올바르지 않은 코드의 존재유무를 검사함
  - 코드 생성기
  - 기계 코드

## 컴파일러의 실행 단계

- 구문 분석: 소스 코드 파일을 읽어 개별 문법요소(연산자, 괄호, 식별자 등) 단위로 자른 후 이 문법 요소들을 해석하여 추상 구문 트리를 생성한다. 이 과정에서 문법에 맞지 않는 소스 코드는 사용자에게 알려준다.
- 최적화: 추상 구문트리를 부넉하여 최적화를 수행한다. 도달할 수 없는 코드를 식별하거나, 상수 표현식을 미리 계산해 두거나, 루프 풀기 등의 대부분의 최적화가 이 단계에서 수해오딘다.
- 코드 생성: 목적 코드 생성
- 링킹: 목적코드가 기계어일 경우 여러 라이브러리 목적 코드를 묶어 하나으 ㅣ실행 파일을 생성하게 된다.



## 목적코드가 실행되는 방법

- 네이티브 컴파일러
  - 리눅스
  - 윈도
- 크로스 컴파일러
  - ARM용 임베디드 시스템용 프로그램