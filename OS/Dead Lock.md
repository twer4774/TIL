# DeadLock(교착상태)

- 두개 이상의 프로세스가 다른 프로세스의 작업이 끝나기를 기다리는 상태
- 발생 원인
  - 상호배제(Mutual Exclusion) : 자원은 한 번에 한 프로세스만 사용할 수 있다
  - 점유와 대기(Hold and Wait): 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있다
  - 비선점(No preemption): 다른 프로세스에 할당된 자원은 사용이 끝날때 까지 강제로 빼앗을 수 없다
  - 순환대기(Circular Wait): 프로세스의 집합 (1, 2, … n)이 있다면 1은 2가 점유한 자원을 대기하고, n은 점유한 자우너을 요구해야 한다.(순환적으로 대기를 만듦)

### 해결방법

- 예방 및 회피 : 예방 또는 회피할 수 있는 프로토콜 이용
  - 예방 - 발생원인을 제거하는 방법, 자원의 낭비가 심함
    - 상호배제 부정 : 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 함
    - 점유대기 부정 : 프로세스가 실행되기 전 필요한 모든 자원을 할당
    - 비선점 부정 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고 요구한 자원을 사용하기 위해 기다리게 함
    - 순환대기 부정 : 자원에 고유한 번호를 할당하고, 번호 순서대로 자원 요구
  - 회피
    - 다익스트라가 제안한 방법으로, 은행원알고리즘(Banker's Algorithm) 이용
    - 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하여 교착 상태를 회피하는 기법
    - 안정 상태에 있으면 자원을 할당하고, 그렇지 않으면 다른 프로세스들이 자원을 해지할 때까지 대기
- 탐지 및 회복 : 교착 상태를 허용하고 회복 시키는 방법
  - 탐지
    - 자원 할당 그래프를 통해 교착상태 탐지
    - 자원을 요청할 때 마다 탐지 알고리즘을 실행하면 오버헤드가 발생
  - 회복
    - 교착 상태를 일으킨 프로세스를 종료하거나 자원을 해제함
- 무시 : 대부분의 시스템에서는 교착상태가 발생하지 않으며, 위의 방법은 비용이 많이 드므로 아예 교착상태를 무시해버린다.

