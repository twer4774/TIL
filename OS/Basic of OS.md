# 운영체제(Operating Systems)

## 운영체제를 위한 기초

### 운영체제의 사용

- 멀티태스킹 운영체제
  - 프로세스: 컴퓨터에서 실행되는 각 작업들
  - 멀태스킹: 여러개으 프로세스들이 적절한 방법으로 돌아가면서 독립적으로 실행
  - 스케줄링: 특정 시점에서 여러개의 프로스세를 실행할 때 어떤 작업을 먼저 실행하느냐를 결정
  - 문맥교환: CPU가 현재 실행하던 프로세스를 보류하고, 스케줄링에 의해 선택된 프로세스를 실행하도록 변경하는 작업

- 운영체제를 사용한다는 것
  - 운영체제는 사용자입력(cmd-Enter, GUI-마우스 클릭)에 따라 적절한 프로세스를 실행해주고, 수시로 프로세스의 요청들을 처리해 준다.
  - 응용프로세스는 자신의 프로그램 코드를 실행하면서 필요에 따라 수시로 운영체제의 기능을 호출한다.
    - 운영체제의 기능: 입출력장치의 구동, 하드웨어 제어
- 하드웨어 - 운영체제 - 응용 프로세스
  - 운영체제가 하드웨어와 응용프로세스 중간에서 위치하면서 응용프로세스가 하드웨어를 직접 제어하지 못하도록 함
  - 장점
    - 프로그래머 입장에서 하드웨어의 세부적인 사항을 모르더라도 프로그램 개발이 가능함(표준 입출력 이용)
    - 응용프로세스의 오류나 불법적인의도(해킹)로 인해 하드웨어가 동작하는 것을 방지할 수 있음
- 운영체제를 사용하는 목적
  - 운영체제의 역할: 다양한 응용 프로그램을 실행, 관리하면서 편리하고 안전하게 실행할 수 있도록 도와줌 => 사용자 입장에서 효율성, 편리성, 안전성이 보장됨
  - 하드웨어 자원의 효율적인 활용: 멀티태스킹 및 적절한 스케줄링으로 CPU, 메모ㄹ 및 입출력 장치들을 최대한 효율적으로 나누어 사용할 수 있게 함 => 빠른 시간 내에 처리 가능
    - 예)
      가상메모리 기능으로 물리적 메모리의 한계를 초과해 프로세스들을 실행 가능하게 함
      디스크 입출력성능 높이기: 디스크 스케줄링, 버퍼 캐시, 지연 기록 방법

| 운영체제를 사용하는 목적      | 설명                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| 하드웨어 자원의 효율적인 활용 | CPU, 메모리, 입출력 장치등의 자원을 프로세스들간에 공유하며 효율적으로 활용 |
| 컴퓨터 사용의 편리성 향상     | 명령어나 마우스 클릭으로 파일 접근 및 파일 접근 및 프로그램 실행, 설치가 가능 |
| 프로그램 개발의 편리성 향상   | 하드웨어의 구체적인 지식이 없어도 프로그램 개발 가능         |
| 프로그램의 이식성 향상        | 하드웨어의 구성이 달라져도 그대로 사용하거나 컴파일 후 실행이 가능함 |
| 컴퓨터의 안전성 향상          | 프로그램의 오류나 바이러스 프로그램으로부터 시스템 보호      |
| 컴퓨터의 보안 강화            | ID, PW등으로 접근 권한 설정                                  |



### 컴퓨터 사용의 편리성

- 사용과정의 편리성
  - cmd, GU에서 프로그램 실행 가능
  - 파이프라인, 리다이렉션 기능으로 입출력 변경
  - 실행중인 프로세스 확인, 중지, 종료, 우선실행 가능
  - 디스크 상의 파일들을 트리 형태로 논리적인 배치 가능
- 개발 과정의 편리성
  - 하드웨어의 구체적인 지식 없이도 개발 가능
  - 디스크 내부 구조 및 처리양식에 대한 고려 없이 파일 생성, 읽기, 쓰기 프로그램 작성 가능
  - 메모리 활용의 세부사항 고려없이, 여러 프로그램을 동시 실행하도록 프로그램 작성 가능



### 운영체제 공부의 장점

- 운영체제 개발 및 이식을 위한 폭 넓은 지식 습득
- 컴퓨터 주변장치 개발: MP3플레이어는 플래시메모리로 컴퓨터가 인식을 해야함 => 장치드라이버 개발(장치드라이버는 운영체제에서 관리함)
- 고성능 응용프로그램 개발: 실행속도가 빠른 프로그램의 개발 가능. 오버헤드가 적은 방법 고려
- 컴퓨터 시스템 관리: 커널 및 시스템 설정 파리미터 조정. 적절한 암호화와 보호모드. 네트워크 접속관련 작업



### 운영체제의 구성

- 프로세스 관리: 프로세스의 생성, 삭제, 중지, 재개
- 메모리관리: 전체 메모리 중에서 비어있는 영역 및 프로세스 별로 사용중인 메모리 영역을 기록하여관리. 메모리 영역 할당 및 회수
- 파일 관리: 전체 디스크 영역을 나누어 관리. 파일 생성, 삭제, 읽기, 쓰기, 크기 조정, 위치이동 등 기능 제공
- 입출력장치관리: 디바이스 드라이버 루틴을 가지고 있어 프로세스의 요청에 따라 적절한 드라이버를 실행함. open, close, read, write, lseek등의 표준 함수 제공
- 시스템 보호 및 보안: 접근 권한 설정으로 프로세스간에 메모리 영역 및 침입을 막고 ,실행중인 다른 프로세스들에 영향을 미치지 못하도록 처리함
- 분산처리: 네트워크를 통하여 연결된 단위의 컴퓨터 시스템의 집합을 사용자 입장에서 하나의 시스템 처럼 사용할 수 있게 해줌
- 명령어 해석기: 사용자가 원하는 작업을 지정할 수 있는 수단을 제공. 입력 -> 운영체제에 해당작업 실행 요청



### 운영체제와 응용프로그램의 실행

- 응용 프로그램 작성 및 실행

  - 실행파일 생성
    - 자체 컴파일러: 프로그램이 실행될 컴퓨터에서 개발
    - 크로스 컴파일러
  - 프로그램 적재
    1. 디스크에 파일 형태로 저장
    2. ROM에 기록 => 전원을 켜면 바로 실행
    3. 직렬포트나 통신망으로 호스트 컴퓨터에서 받아와 메모리에 적재 후 실행

- 명령어 해석기의 역할

  - 사용자로 부터 입력을 받아 적절한 프로그램 실행

  - 셀과 GUI

    - 프로그램 실행 과정

    1. 셀: 실행 파일을 받아 들일 대기 상태(프롬프트 출력)
    2. 사용자: 실행파일을 사용자가 입력(Enter)
    3. 셀: 첫 단어를 실행될 프로그램 파일의 이름으로 지정하여 우녕ㅇ체제에 실행을 요청하는 함수 호출(fork 및 exec 시스템 콜 함수)
    4. 운영체제: 빈 메모리 공간을 확보하고 지정된 파일을 디스크로 부터 메모리로 읽어 들인 후 프로그램으 실행위치로 이동
    5. 응용프로그램: 실행 후 종료를 위한 운영체제 함수 호출(exit 시스템 콜 함수)
    6. 운영체제: 종료된 프로그램의 메모리 영역을 빈 영역으로 기록 => 셀의 실행위치로 이동
    7. 셀: 다음 프로그램의 실행을 위해 1번부터 작업 반복

- 부팅절차

1. 전원을 켜면 ROM의 프로그램 작동.
   메모리 크기나하드웨어 검사 실시 후 부트 디스크의 부트로더를 읽어 메모리에 적재 후 실행
2. 부트 로더는 실행도리 운영체제 파일을 부트 디스크에서 찾아 메모리의 지정 주소에 적재 후 실행
3. 운영체제 커널은 각종 변수들 및 입출력 장치들을 초기화한 후 명령해석기 실행
4. 명령해석기는 프롬프트를 출력한 후 사용자로부터 명령을 읽어 들이고 운영체제에 이 명령에 해당하는 프로그램 파일로 새로운 프로세스를 생성해 실행시키도록 요청

